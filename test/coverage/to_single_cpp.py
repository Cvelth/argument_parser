# Cvelth <Cvelth.mail@gmail.com> © 2020
# version 0.1

import argparse
import re
from pathlib import Path

parser = argparse.ArgumentParser(description='Concatenates all the files from two paths into a single file.')
parser.add_argument('--include', '-i', help='include paths, separator: \';\'')
parser.add_argument('--source', '-s', help='source paths, separator: \';\'')
parser.add_argument('--output', '-o', help='output path', default='.')
parser.add_argument('--filename', '-f', help='output filename', default='output')

args = parser.parse_args()

includes = args.include.split(';')
sources = args.source.split(';')
output = args.output
name = args.filename + '.cpp'

added_includes = []
def should_be_kept(line):
    if (line == '#pragma once\n'):
        return False
    m = re.match('^#include ["<](.*)[">]\n$', line)
    if (m):
        return not m.group(1) in added_includes

    return True


Path(output).mkdir(exist_ok=True)
out = open(output + '/' + name, 'w+')
out.write('// This file is automatically generated by `to_single_cpp.py` (v0.1) script.\n')
out.write('// Do not modify!\n')
out.write('\n') 
out.write('// Cvelth <Cvelth.mail@gmail.com> © 2020\n\n')

out.write('// @to_single_cpp begin\n')

for include_dir in includes:
    for filename in list(Path(include_dir).rglob("*.[hH][pP][pP]")) + list(Path(include_dir).rglob("*.[hH]")):
        print(str(filename))
        with open(filename, 'r') as f:
            out.write('// @to_single_cpp include_file_begin ' + str(filename).split('/')[-1] + ' (' + str(filename) + ')\n')
            for line in f:
                if (should_be_kept(line)):
                    out.write(line)
            out.write('\n// @to_single_cpp include_file_end ' + str(filename).split('/')[-1] + ' (' + str(filename) + ')\n')
        added_includes.append(str(filename).split('/')[-1])
for source_dir in sources:
    for filename in list(Path(source_dir).rglob("*.[hHcC][pP][pP]")) + list(Path(source_dir).rglob("*.[hHcC]")):
        print(str(filename))
        with open(filename, 'r') as f:
            out.write('// @to_single_cpp source_file_begin ' + str(filename).split('/')[-1] + ' (' + str(filename) + ')\n')
            for line in f:
                if (should_be_kept(line)):
                    out.write(line)
            out.write('\n// @to_single_cpp source_file_end ' + str(filename).split('/')[-1] + ' (' + str(filename) + ')\n')
        added_includes.append(str(filename).split('/')[-1])

out.write('// @to_single_cpp end\n')
